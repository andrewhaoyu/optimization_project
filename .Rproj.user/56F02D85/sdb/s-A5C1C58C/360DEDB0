{
    "collab_server" : "",
    "contents" : "# Parameters to be tuned\n# commandarg <- commandArgs(trailingOnly = T)\n# i1 <- as.integer(commandarg[[1]])\n# print(i1)\n# set.seed(i1)\n\nlibrary(Matrix)\n\nset.seed(12345)\n# simulationtimes <- 1\ngernating.function <- function(r0,r1){\n  result <- rep(0,length(r0))\n  idx <- which(r0==0&r1==0)\n  result[idx] <- (rbinom(length(idx),1,0.3)+1)\n  idx <- which(r0==0&r1==1)\n  result[idx] <- (rbinom(length(idx),1,0.5)+1)\n  idx <- which(r0==1&r1==1)\n  result[idx] <- (rbinom(length(idx),1,0.7)+1)\n  return(result)\n  \n}\n\n\n\n\n\n\nquadmax <- function(z,r,y){\n  idx_1 <- which(z==1)\n  idx_0 <- which(z==0)\n  idx_1_NA <- which(z==1&r==0)\n  idx_0_NA <- which(z==0&r==0)\n  n1_NA <- length(idx_1_NA)\n  n0_NA <- length(idx_0_NA)\n  n1 <- sum(data[,1])\n  Q <- matrix(-1/((n-1)*n1*(n-n1)),n,n)\n  diag(Q) <- 1/(n1*(n-n1))\n  \n  y_fit <- y\n  \n  \n  \n  \n  for(k in 0:(n1_NA+n0_NA)){\n    \n    temp_y_1 <- rep(2,length(idx_1_NA))\n    temp_y_0 <- rep(2,length(idx_0_NA))\n    if(k==0){\n      y_fit[idx_1_NA] <- temp_y_1\n      y_fit[idx_0_NA] <- temp_y_0\n      test_result <- test(y_fit,idx_1,idx_0,Q)\n      if(test_result==1){\n        #print(k)\n        return(list(quadmax=mean(y_fit),y_fit=y_fit))\n      }\n      \n    }else{\n      pcom <- generate(k,n1_NA,n0_NA)\n      if(class(pcom)==\"numeric\"){\n        pcom <- matrix(pcom,1,2)\n      }\n      for(i in 1:nrow(pcom)){\n        y_fit <- y\n        n1_change <- pcom[i,1]\n        n0_change <- pcom[i,2]\n        temp_y_1 <- rep(2,length(idx_1_NA))\n        temp_y_0 <- rep(2,length(idx_0_NA))\n        if(n1_change!=0){\n          temp_y_1[1:n1_change] <- 1 \n        }\n        if(n0_change!=0){\n          temp_y_0[1:n0_change] <- 1\n        }\n        \n        y_fit[idx_1_NA] <- temp_y_1\n        y_fit[idx_0_NA] <- temp_y_0\n        test_result <- test(y_fit,idx_1,idx_0,Q)\n        if(test_result==1){\n          #print(c(k,i))\n          return(list(quadmax=mean(y_fit),y_fit=y_fit))\n        }\n      }\n    }\n    \n  }\n}\n\nquadmin <- function(z,r,y){\n  idx_1 <- which(z==1)\n  idx_0 <- which(z==0)\n  idx_1_NA <- which(z==1&r==0)\n  idx_0_NA <- which(z==0&r==0)\n  n1_NA <- length(idx_1_NA)\n  n0_NA <- length(idx_0_NA)\n  n1 <- sum(data[,1])\n  Q <- matrix(-1/((n-1)*n1*(n-n1)),n,n)\n  diag(Q) <- 1/(n1*(n-n1))\n  \n  y_fit <- y\n  \n  \n  \n  \n  for(k in 0:(n1_NA+n0_NA)){\n    \n    temp_y_1 <- rep(1,length(idx_1_NA))\n    temp_y_0 <- rep(1,length(idx_0_NA))\n    if(k==0){\n      y_fit[idx_1_NA] <- temp_y_1\n      y_fit[idx_0_NA] <- temp_y_0\n      test_result <- test(y_fit,idx_1,idx_0,Q)\n      if(test_result==1){\n        #print(k)\n        return(list(quadmin=mean(y_fit),y_fit=y_fit))\n      }\n      \n    }else{\n      pcom <- generate(k,n1_NA,n0_NA)\n      if(class(pcom)==\"numeric\"){\n        pcom <- matrix(pcom,1,2)\n      }\n      for(i in 1:nrow(pcom)){\n        y_fit <- y\n        n1_change <- pcom[i,1]\n        n0_change <- pcom[i,2]\n        temp_y_1 <- rep(1,length(idx_1_NA))\n        temp_y_0 <- rep(1,length(idx_0_NA))\n        if(n1_change!=0){\n          temp_y_1[1:n1_change] <- 2\n        }\n        if(n0_change!=0){\n          temp_y_0[1:n0_change] <- 2\n        }\n        \n        y_fit[idx_1_NA] <- temp_y_1\n        y_fit[idx_0_NA] <- temp_y_0\n        test_result <- test(y_fit,idx_1,idx_0,Q)\n        if(test_result==1){\n          #print(c(k,i))\n          return(list(quadmin=mean(y_fit),y_fit=y_fit))\n        }\n      }\n    }\n    \n  }\n}\n\n\ntest <- function(y_fit,idx_1,idx_0,Q){\n  differ <- abs(mean(y_fit[idx_1])-mean(y_fit[idx_0]))\n  sd_differ <- sqrt(t(y_fit)%*%Q%*%y_fit)\n  test <- differ/sd_differ\n  result <- ifelse(test<=qnorm(0.975),1,0)\n  return(result)\n}\n\n\ngenerate <- function(k,n1_NA,n0_NA){\n  if(k==0){\n    return(matrix(0,1,2))\n  }else{\n    result <- matrix(0,k+1,2)\n    result[,1] <- c(0:k)\n    result[,2] <- c(k:0)\n    idx <- which(result[,1]>n1_NA|result[,2]>n0_NA)\n    if(length(idx)==0){\n      return(result)\n    }else{\n      result <- result[-idx,]}\n    return(result)\n  }\n}\n\n\ngenerate.c <- function(y.fit,z,r){\n  result <- rep(0,3*K*length(z))\n  for(i in 1:length(z)){\n    result[(6*i-5):(6*i)] <- generate.c.indi(y.fit[i],z[i],r[i])\n  }\n  return(result)\n}\n\ngenerate.c.indi <- function(y.fit.ind,z,r){\n  result <- NULL\n  if(z==1&r==0){\n    if(y.fit.ind==1){\n      result <- c(0,0,0,0,1,0)\n    }else{\n      result <- c(0,0,0,0,0,1)\n    }\n  }else if(z==0&r==1){\n    if(y.fit.ind==1){\n      result <- c(1,0,0,0,0,0)\n    }else{\n      result <- c(0,1,0,0,0,0)\n    }\n  }else{\n    if(y.fit.ind==1){\n      result <- c(0,0,1,0,0,0)\n    }else{\n      result <- c(0,0,0,1,0,0)\n    }\n  }\n  return(result)\n}\n\nexplain.c <- function(x){\n  y_ex <- rep(0,length(x)/(3*K))\n  for(i in 1:(length(x)/(3*K))){\n    temp <- x[(6*i-5):(6*i)]\n    if(sum(temp[c(1,3,5)])==1){\n      y_ex[i] <- 1\n    }else{\n      y_ex[i] <- 2\n    }\n  }\n  return(y_ex)\n}\n\n\n\ndirect.est <- function(z,r,y){\n  n1 <- sum(z==1)\n  n <- length(z)\n  n0 <- n-n1\n  idx.z1.r1 <- which(z==1&r==1)\n  e.z1.r1 <- mean(y[idx.z1.r1])\n  p.r1_z1 <- length(idx.z1.r1)/n1\n  b <- e.z1.r1*p.r1_z1\n  p.r0_z1 <- 1-p.r1_z1\n  a <- p.r0_z1\n  \n  idx.z0.r1 <- which(z==0&r==1)\n  p.r1_z0 <- length(idx.z0.r1)/n0\n  e.r1_z0 <- mean(y[idx.z0.r1])\n  d <- p.r1_z0*e.r1_z0\n  p.r0_z0 <- 1-p.r1_z0\n  c <- p.r0_z0\n  \n  if(((a+b-d)/c)>=1){\n    lx <- 1\n  }else{\n    lx <- (c+d-b)/a\n  }\n  \n  if(((a+b-d)/c)<=2){\n    ux <- 2\n  }else{\n    ux <- (2*c+d-b)/a\n  }\n  \n  obl <- lx*a+b\n  obu <- ux*a+b\n  return(c(obl,obu))\n  \n}\n\n\n\n\n\n\n###main funciton\nsimulationtimes <- 300\nresult_test <- matrix(0,simulationtimes,4)\nfor(simulation in 1:simulationtimes){\n  n <-500# total number of people\n  K <- 2 # number of levels for Likert outcome\n  result <- matrix(0,nrow=simulationtimes,ncol=(6+2*3*K*n))\n  final_result <- NULL\n  #simulation <- simulationtimes\n  \n  print(paste0(\"we are in\",simulation,\"th run\"))\n  # n <-25# total number of people\n  # K <- 2 # number of levels for Likert outcome\n  # \n  # Start simulation\n  \n  #y <- sample(1:K,n,replace = T)\n  r1samp <- rbinom(n,1,0.8)\n  r2samp <- rbinom(n,1,0.5)\n  r0 <- pmin(r1samp,r2samp) # whether the individual will respond under low incentive\n  r1 <- pmax(r1samp,r2samp) # whether the individual will respond under high incentive\n  z <- rbinom(n,1,0.5) # the individual receive high or low incentive\n  r <- ifelse(z==1,r1,r0) # observed response indicator\n  \n  y <- gernating.function(r0,r1)\n  c <- cbind(sapply(1:K,function(sk) as.integer(r0==1 & y==sk)),sapply(1:K,function(sk) as.integer(r0==0 & r1==1 & y==sk)),sapply(1:K,function(sk) as.integer(r0==0 & r1==0 & y==sk)))\n  tmpid <- expand.grid(1:3,1:K)\n  colnames(c) <- apply(tmpid[order(tmpid[,1],tmpid[,2]),],1,paste0,collapse=\".\")\n  \n  # Check conditions\n  # table(rowSums(c)) # check whether each row of c sum up to 1\n  # # condition 1 should be 1, 0\n  # unique(rowSums(c[z==1 & r==0,grep(\"3.\",colnames(c))]))\n  # unique(rowSums(c[z==1 & r==0,!grepl(\"3.\",colnames(c))]))\n  # # condition 2 should be 1, 0\n  # table(rowSums(c[z==0 & r==0,grepl(\"2.\",colnames(c)) | grepl(\"3.\",colnames(c))]))\n  # table(rowSums(c[z==0 & r==0,grepl(\"1.\",colnames(c))]))\n  # # condition 3 should be 1, 0\n  # sapply(1:K, function(sk) {\n  #   c(unique(rowSums(c[z==1 & r==1 & y==sk,c(paste0(c(1,2),\".\",sk))])),\n  #     unique(rowSums(c[z==1 & r==1 & y==sk,!colnames(c) %in% c(paste0(c(1,2),\".\",sk))])))\n  # })\n  # # condition 4 should be 1, 0\n  # sapply(1:K, function(sk) {\n  #   c(unique(c[z==0 & r==1 & y==sk,paste0(\"1.\",sk)]),\n  #     unique(rowSums(c[z==0 & r==1 & y==sk,!colnames(c) %in% paste0(\"1.\",sk)])))\n  # })\n  completedata <- cbind(z,r,y)\n  \n  true.y <- mean(completedata[,3])\n  \n  \n  \n  idx <- which(r==0)\n  y[idx] <- NA\n  data <- cbind(z,r,y)\n  idx_0<- which(z==0)\n  idx_1 <- which(z==1)\n  idx_0_NA <- which(z==0&r==0)\n  idx_1_NA <- which(z==1&r==0)\n  n1 <- sum(data[,1])\n  Q <- matrix(-1/((n-1)*n1*(n-n1)),n,n)\n  diag(Q) <- 1/(n1*(n-n1))\n  \n  temp_y_0 <- rep(1,length(idx_0_NA))\n  temp_y_1 <- rep(1,length(idx_1_NA))\n  \n  result_mean <- rep(1,length(idx_1_NA))\n  \n  ### make both groups as all 1\n  temp_y_0 <- rep(2,length(idx_0_NA))\n  \n  temp_y_1 <- rep(2,length(idx_1_NA))\n  \n  #y_fit <- y\n  #y_fit[idx_0_NA] <- temp_y_0\n  # y_fit[idx_1_NA] <- temp_y_1\n  # differ <- abs(mean(y_fit[idx_0])-mean(y_fit[idx_1]))\n  \n  #sd_dif <- sqrt(t(y_fit)%*%Q%*%y_fit)\n  result_test[simulation,1] <- quadmin(z,r,y)$quadmin\n  result_test[simulation,2] <- quadmax(z,r,y)$quadmax\n  result_test[simulation,c(3:4)] <- direct.est(z,r,y)\n  \n}\n\nlower <- result_test[,1]\nupper <- result_test[,2]\nln <- result_test[,3]\nun <- result_test[,4]\nlibrary(ggplot2)\nresult_test <- data.frame(result_test)\ncolnames(result_test) <- c(\"lower\",\"upper\",\"ln\",\"un\")\nf <- ggplot(result_test,aes(ln,un))+geom_point()+geom_vline(xintercept = 1.53,col=\"red\")+geom_hline(yintercept = 1.63,col=\"red\")+geom_point(aes(lower,upper),col=\"blue\")\n\n",
    "created" : 1482287341402.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "93664780",
    "id" : "360DEDB0",
    "lastKnownWriteTime" : 1482366812,
    "last_content_update" : 1482366812414,
    "path" : "~/Documents/study/advanced_ stat_theory/optimization_project/simulation3.R",
    "project_path" : "simulation3.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}