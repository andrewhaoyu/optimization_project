{
    "collab_server" : "",
    "contents" : "# Parameters to be tuned\ncommandarg <- commandArgs(trailingOnly = T)\ni1 <- as.integer(commandarg[[1]])\nset.seed(i1)\n\nlibrary(gurobi)\nsimulationtimes <- 1\nresult <- matrix(0,nrow=simulationtimes,ncol=2)\nsimulation <- simulationtimes\n  n <- 100 # total number of people\n  K <- 2 # number of levels for Likert outcome\n  \n  # Start simulation\n  \n  #y <- sample(1:K,n,replace = T)\n  r1samp <- rbinom(n,1,0.5)\n  r2samp <- rbinom(n,1,0.5)\n  r0 <- pmin(r1samp,r2samp) # whether the individual will respond under low incentive\n  r1 <- pmax(r1samp,r2samp) # whether the individual will respond under high incentive\n  z <- rbinom(n,1,0.5) # the individual receive high or low incentive\n  r <- ifelse(z==1,r1,r0) # observed response indicator\n  gernating.function <- function(r0,r1){\n   result <- rep(0,length(r0))\n   idx <- which(r0==0&r1==0)\n     result[idx] <- (rbinom(length(idx),1,0.3)+1)\n     idx <- which(r0==0&r1==1)\n     result[idx] <- (rbinom(length(idx),1,0.5)+1)\n     idx <- which(r0==1&r1==1)\n     result[idx] <- (rbinom(length(idx),1,0.7)+1)\n     return(result)\n   \n  }\n  y <- gernating.function(r0,r1)\n   c <- cbind(sapply(1:(K),function(sk) as.integer(r0==1 & y==sk)),sapply(1:(K),function(sk) as.integer(r0==0 & r1==1 & y==sk)),sapply(1:(K),function(sk) as.integer(r0==0 & r1==0 & y==sk)))\n   tmpid <- expand.grid(1:3,1:(K))\n   colnames(c) <- apply(tmpid[order(tmpid[,1],tmpid[,2]),],1,paste0,collapse=\".\")\n\n  # Check conditions\n  table(rowSums(c)) # check whether each row of c sum up to 1\n  # condition 1 should be 1, 0\n  unique(rowSums(c[z==1 & r==0,grep(\"3.\",colnames(c))]))\n  unique(rowSums(c[z==1 & r==0,!grepl(\"3.\",colnames(c))]))\n  # condition 2 should be 1, 0\n  table(rowSums(c[z==0 & r==0,grepl(\"2.\",colnames(c)) | grepl(\"3.\",colnames(c))]))\n  table(rowSums(c[z==0 & r==0,grepl(\"1.\",colnames(c))]))\n  # condition 3 should be 1, 0\n  sapply(1:(K), function(sk) {\n    c(unique(rowSums(c[z==1 & r==1 & y==sk,c(paste0(c(1,2),\".\",sk))])),\n      unique(rowSums(c[z==1 & r==1 & y==sk,!colnames(c) %in% c(paste0(c(1,2),\".\",sk))])))\n  })\n  # condition 4 should be 1, 0\n  sapply( 1:(K), function(sk) {\n    c(unique(c[z==0 & r==1 & y==sk,paste0(\"1.\",sk)]),\n      unique(rowSums(c[z==0 & r==1 & y==sk,!colnames(c) %in% paste0(\"1.\",sk)])))\n  })\n  completedata <- cbind(z,r,y)\n  true.y <- mean(completedata[,3])\n  c.true <- as.vector(t(c))\n  \n  idx <- which(r==0)\n  y[idx] <- NA\n  data <- cbind(z,r,y)\n  b <- rep(c(1:K),3*n)\n  \n  total <- length(b)\n  cvec <- 1/n*(b)\n  ub <- 1\n  lb <- 0\n  Amat <- matrix(0,nrow=n,ncol=total)\n  temp <- rep(1,3*K)\n  K3 <- 3*K\n  for(i in 1:n){\n    Amat[i,(1+(i-1)*length(temp)):(i*length(temp))] <- temp\n  }\n  bvec <- rep(1,n)\n  sense <- rep('E',n)\n  idx <- which(data[,1]==1&data[,2]==0)\n  Amat_temp <- matrix(0,nrow=length(idx),ncol=total)\n  for(i in 1:length(idx)){\n    Amat_temp[i,((idx[i]-1)*K3+2*K+1):((idx[i]-1)*K3+K3)] <- rep(1,K)\n  }\n  sense_temp <- rep('E',length(idx))\n  bvec_temp <- rep(1,length(idx))\n  Amat <- rbind(Amat,Amat_temp)\n  sense <- c(sense,sense_temp)\n  bvec <- c(bvec,bvec_temp)\n  idx <- which(data[,1]==0&data[,2]==0)\n  Amat_temp <- matrix(0,nrow=length(idx),ncol=total)\n  for(i in 1:length(idx)){\n    Amat_temp[i,((idx[i]-1)*K*3+K+1):((idx[i]-1)*K3+K3)] <- rep(1,2*K)\n  }\n  sense_temp <- rep('E',length(idx))\n  bvec_temp <- rep(1,length(idx))\n  Amat <- rbind(Amat,Amat_temp)\n  sense <- c(sense,sense_temp)\n  bvec <- c(bvec,bvec_temp)\n  \n  jdx <- which(data[,1]==1&data[,2]==1)\n  Amat_temp <- matrix(0,nrow=length(jdx),ncol=total)\n  for(j in 1:length(jdx)){\n    y.jdx <- data[jdx[j],3]\n    Amat_temp[j,(jdx[j]-1)*K3+y.jdx] <- 1\n    Amat_temp[j,(jdx[j]-1)*K3+K+y.jdx] <- 1\n  }\n  sense_temp <- rep('E',length(jdx))\n  bvec_temp <- rep(1,length(jdx))\n  Amat <- rbind(Amat,Amat_temp)\n  sense <- c(sense,sense_temp)\n  bvec <- c(bvec,bvec_temp)\n  \n  jdx <- which(data[,1]==0&data[,2]==1)\n  Amat_temp <- matrix(0,nrow=length(jdx),ncol=total)\n  for(j in 1:length(jdx)){\n    y.jdx <- data[jdx[j],3]\n    Amat_temp[j,(jdx[j]-1)*K3+y.jdx] <- 1\n  }\n  sense_temp <- rep('E',length(jdx))\n  bvec_temp <- rep(1,length(jdx))\n  Amat <- rbind(Amat,Amat_temp)\n  sense <- c(sense,sense_temp)\n  bvec <- c(bvec,bvec_temp)\n  n1 <- sum(data[,1])\n  a <- data[,1]/n1-(1-data[,1])/(n-n1)\n  Q <- matrix(-1/((n-1)*n1*(n-n1)),n,n)\n  diag(Q) <- 1/(n1*(n-n1))\n  B <- kronecker(diag(n),rep(1:K,3))\n  Qmat <- B%*%(a%*%t(a)-3.84*Q)%*%t(B)\n  c.true%*%Qmat%*%c.true\n  eigen_decom <- eigen(Qmat)\n  u <- try$u\n  eigen_adjust <- eigen_decom$values\n  eigen_adjust[abs(eigen_adjust)<1e-15] <- 0\n  D <- diag(eigen_adjust)\n  delta <- eigen_decom$vectors\n  Q_eigen <- delta%*%D%*%solve(delta)\n  c.true%*%Qmat%*%c.true\n  c.true%*%Q_eigen%*%c.true\n  ub <- rep(1,total)\n  lb <- rep(0,total)\n  vtypes <- rep(\"B\",total)\n  sense <- rep(\"=\",length(bvec))\n  model <- list()\n  model$A <- Amat\n  model$modelsense <- \"max\"\n  model$obj <- cvec\n  model$rhs <- bvec\n  model$sense <- sense\n  model$vtypes <- vtypes\n  # model$ub <- ub\n  # model$lb <- lb\n  \n  qc1 <- list()\n  qc1$Qc <- Q_eigen\n  qc1$rhs <- 0.0\n  model$quadcon <- list(qc1)\n  res <- gurobi(model)\n  c_gurobi <- res$x\n  result[simulation,1] <- res$objval\n  model$modelsense <- \"min\"\n  res <- gurobi(model)\n  result[simulation,2] <- res$objval\n\nsave(result,file=paste0(\"/users/hzhang1/R/Dan/simulation1/result\",i1,\".Rdata\"))\n\n\n\n\n\n\n\n\n",
    "created" : 1480829304228.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2526071147",
    "id" : "2259AA02",
    "lastKnownWriteTime" : 1481741721,
    "last_content_update" : 1481741721295,
    "path" : "~/Documents/study/advanced_ stat_theory/optimization_project/simulation1.R",
    "project_path" : "simulation1.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}