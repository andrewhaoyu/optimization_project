{
    "collab_server" : "",
    "contents" : "# Parameters to be tuned\ncommandarg <- commandArgs(trailingOnly = T)\ni1 <- as.integer(commandarg[[1]])\nprint(i1)\nset.seed(i1)\n\nlibrary(Matrix)\n\nlibrary(gurobi)\nsimulationtimes <- 1\nn <-50# total number of people\nK <- 2 # number of levels for Likert outcome\nresult <- matrix(0,nrow=simulationtimes,ncol=(6+2*3*K*n))\nfinal_result <- NULL\nsimulation <- simulationtimes\n  \n  print(paste0(\"we are in\",simulation,\"th run\"))\n  # n <-25# total number of people\n  # K <- 2 # number of levels for Likert outcome\n  # \n  # Start simulation\n  \n  #y <- sample(1:K,n,replace = T)\n  r1samp <- rbinom(n,1,0.8)\n  r2samp <- rbinom(n,1,0.5)\n  r0 <- pmin(r1samp,r2samp) # whether the individual will respond under low incentive\n  r1 <- pmax(r1samp,r2samp) # whether the individual will respond under high incentive\n  z <- rbinom(n,1,0.5) # the individual receive high or low incentive\n  r <- ifelse(z==1,r1,r0) # observed response indicator\n  gernating.function <- function(r0,r1){\n    result <- rep(0,length(r0))\n    idx <- which(r0==0&r1==0)\n    result[idx] <- (rbinom(length(idx),1,0.3)+1)\n    idx <- which(r0==0&r1==1)\n    result[idx] <- (rbinom(length(idx),1,0.5)+1)\n    idx <- which(r0==1&r1==1)\n    result[idx] <- (rbinom(length(idx),1,0.7)+1)\n    return(result)\n    \n  }\n  y <- gernating.function(r0,r1)\n  c <- cbind(sapply(1:K,function(sk) as.integer(r0==1 & y==sk)),sapply(1:K,function(sk) as.integer(r0==0 & r1==1 & y==sk)),sapply(1:K,function(sk) as.integer(r0==0 & r1==0 & y==sk)))\n  tmpid <- expand.grid(1:3,1:K)\n  colnames(c) <- apply(tmpid[order(tmpid[,1],tmpid[,2]),],1,paste0,collapse=\".\")\n  \n  # Check conditions\n  # table(rowSums(c)) # check whether each row of c sum up to 1\n  # # condition 1 should be 1, 0\n  # unique(rowSums(c[z==1 & r==0,grep(\"3.\",colnames(c))]))\n  # unique(rowSums(c[z==1 & r==0,!grepl(\"3.\",colnames(c))]))\n  # # condition 2 should be 1, 0\n  # table(rowSums(c[z==0 & r==0,grepl(\"2.\",colnames(c)) | grepl(\"3.\",colnames(c))]))\n  # table(rowSums(c[z==0 & r==0,grepl(\"1.\",colnames(c))]))\n  # # condition 3 should be 1, 0\n  # sapply(1:K, function(sk) {\n  #   c(unique(rowSums(c[z==1 & r==1 & y==sk,c(paste0(c(1,2),\".\",sk))])),\n  #     unique(rowSums(c[z==1 & r==1 & y==sk,!colnames(c) %in% c(paste0(c(1,2),\".\",sk))])))\n  # })\n  # # condition 4 should be 1, 0\n  # sapply(1:K, function(sk) {\n  #   c(unique(c[z==0 & r==1 & y==sk,paste0(\"1.\",sk)]),\n  #     unique(rowSums(c[z==0 & r==1 & y==sk,!colnames(c) %in% paste0(\"1.\",sk)])))\n  # })\n  completedata <- cbind(z,r,y)\n  true.y <- mean(completedata[,3])\n  \n  idx <- which(r==0)\n  y[idx] <- NA\n  data <- cbind(z,r,y)\n  b <- rep(c(1:K),3*n)\n  \n  total <- length(b)\n  cvec <- c(1/n*(b))\n  \n  ub <- 1\n  lb <- 0\n  Amat <- matrix(0,nrow=n,ncol=total)\n  temp <- rep(1,3*K)\n  K3 <- 3*K\n  for(i in 1:n){\n    Amat[i,(1+(i-1)*length(temp)):(i*length(temp))] <- temp\n  }\n  bvec <- rep(1,n)\n  sense <- rep('=',n)\n  idx <- which(data[,1]==1&data[,2]==0)\n  if(length(idx)!=0){\n    Amat_temp <- matrix(0,nrow=length(idx),ncol=total)\n    for(i in 1:length(idx)){\n      Amat_temp[i,((idx[i]-1)*K3+2*K+1):((idx[i]-1)*K3+K3)] <- rep(1,K)\n    }\n    sense_temp <- rep('=',length(idx))\n    bvec_temp <- rep(1,length(idx))\n    Amat <- rbind(Amat,Amat_temp)\n    sense <- c(sense,sense_temp)\n    bvec <- c(bvec,bvec_temp)\n  }\n  \n  idx <- which(data[,1]==0&data[,2]==0)\n  if(length(idx)!=0){\n    Amat_temp <- matrix(0,nrow=length(idx),ncol=total)\n    for(i in 1:length(idx)){\n      Amat_temp[i,((idx[i]-1)*K*3+K+1):((idx[i]-1)*K3+K3)] <- rep(1,2*K)\n    }\n    sense_temp <- rep('=',length(idx))\n    bvec_temp <- rep(1,length(idx))\n    Amat <- rbind(Amat,Amat_temp)\n    sense <- c(sense,sense_temp)\n    bvec <- c(bvec,bvec_temp)\n  }\n  \n  \n  jdx <- which(data[,1]==1&data[,2]==1)\n  if(length(jdx)!=0){\n    Amat_temp <- matrix(0,nrow=length(jdx),ncol=total)\n    for(j in 1:length(jdx)){\n      y.jdx <- data[jdx[j],3]\n      Amat_temp[j,(jdx[j]-1)*K3+y.jdx] <- 1\n      Amat_temp[j,(jdx[j]-1)*K3+K+y.jdx] <- 1\n    }\n    sense_temp <- rep('=',length(jdx))\n    bvec_temp <- rep(1,length(jdx))\n    Amat <- rbind(Amat,Amat_temp)\n    sense <- c(sense,sense_temp)\n    bvec <- c(bvec,bvec_temp)\n  }\n  \n  \n  jdx <- which(data[,1]==0&data[,2]==1)\n  if(length(jdx)!=0){\n    Amat_temp <- matrix(0,nrow=length(jdx),ncol=total)\n    for(j in 1:length(jdx)){\n      y.jdx <- data[jdx[j],3]\n      Amat_temp[j,(jdx[j]-1)*K3+y.jdx] <- 1\n    }\n    sense_temp <- rep('=',length(jdx))\n    bvec_temp <- rep(1,length(jdx))\n    Amat <- rbind(Amat,Amat_temp)\n    sense <- c(sense,sense_temp)\n    bvec <- c(bvec,bvec_temp)\n  }\n  \n  \n  \n  \n  n1 <- sum(data[,1])\n  a <- data[,1]/n1-(1-data[,1])/(n-n1)\n  Q <- matrix(-1/((n-1)*n1*(n-n1)),n,n)\n  diag(Q) <- 1/(n1*(n-n1))\n  B <- kronecker(diag(n),rep(1:K,3))\n  Qmat <- B%*%(a%*%t(a)-qnor*Q)%*%t(B)\n  eigen_decom <- eigen(Qmat)\n  eigen_adjust <- eigen_decom$values\n  eigen_adjust[abs(eigen_adjust)<1e-15] <- 0\n  D <- diag(eigen_adjust)\n  delta <- eigen_decom$vectors\n  Q_eigen <- delta%*%D%*%solve(delta)\n  \n \n  \n  \n  \n  #ub <- rep(1,total)\n  #lb <- rep(0,total)\n  vtypes <- rep(\"B\",ncol(Amat))\n  sense <- rep(\"=\",length(bvec))\n  model <- list()\n  model$A <- Amat\n  model$modelsense <- \"max\"\n  model$obj <- cvec\n  model$rhs <- bvec\n  model$sense <- sense\n  model$vtypes <- vtypes\n  # model$ub <- ub\n  # model$lb <- lb\n  \n  qc1 <- list()\n  qc1$Qc <- Q_eigen\n  qc1$rhs <- 0.0\n  model$quadcon <- list(qc1)\n  print(\"first step is okay\")\n  params <- list(MIPGap=0.0059,TimeLimit = 3600)\n  #res <- gurobi(model,params)\n  res1 <- gurobi(model,params)\n  print(\"gurobi can be run out for max!!!!!!\")\n  if (is.null(res1$objval)){\n    result[simulation,1] <- NA\n    result[simulation,7:(6+3*K*n)] <- NA\n  }else{\n    result[simulation,1] <- res1$objval\n    result[simulation,7:(6+3*K*n)] <- res1$x\n  }\n  result[simulation,4] <- res1$runtime\n  \n  model$modelsense <- \"min\"\n  res2 <- gurobi(model,params)\n  print(\"gurobi can run out for min!!!!!\")\n  if(is.null(res2$objval)){\n    result[simulation,2] <- NA\n    result[simulation,(7+3*K*n):(6+3*K*2*n)] <- NA\n  }else{\n    result[simulation,2] <- res2$objval\n    result[simulation,(7+3*K*n):(6+3*K*2*n)] <- res2$x\n  }\n  # result[simulation,2] <- res$objval\n  result[simulation,3] <- true.y\n  result[simulation,5] <- res2$runtime\n  result[simulation,6] <- i1\n  \n  \n  \n  final_result_temp <- list(result=result,res1=res1,res2=res2,completedata=completedata,\n                            data=data)\n  \n  final_result[[simulation]] <- final_result_temp\n  \n  \n\nsave(result,file=paste0(\"/users/hzhang1/R/Dan/simulation1/result_final_adj\",i1,\".Rdata\"))\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1480877351159.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "589774775",
    "id" : "1D2E49B2",
    "lastKnownWriteTime" : 1482366813,
    "last_content_update" : 1482366813844,
    "path" : "~/Documents/study/advanced_stat_theory/optimization_project/simulation2.R",
    "project_path" : "simulation2.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}