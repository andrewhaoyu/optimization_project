{
    "collab_server" : "",
    "contents" : "library(MASS)\nlibrary(mvtnorm)\nlibrary(NlcOptim)\nlibrary(Rsolnp)\nlibrary(alabama)\ncomputefunction <- function(a,b){\n  \n  mu1 <- mu[1]\n  sigma1 <- sqrt(Sigma[1,1])\n  result <- pmvnorm(lower=c(a,-Inf),upper = c(Inf,b),mean=mu,sigma=Sigma)\n  return((result[1]-0.95))\n}\n\nfn <- function(x){return(x[2]-x[1])}\ngr <- function(x){\n  g <- rep(NA,2)\n  g[1] <- -1\n  g[2] <- 1\n  return(g)\n}\nheq <- function(x){\n  h <- (computefunction(x[1],x[2]))\n  return(h)\n}\nheq.jac <- function(x){\n  j <- matrix(NA,1,length(x))\n  j[1,1] <- computefunction_grad_1(x[1],x[2])\n  j[1,2] <- computefunction_grad_2(x[1],x[2])\n  return(j)\n}\nhin <- function(x){\n  h <- rep(NA,3)\n  h[1] <- x[2]-x[1]\n  h[2] <- x[1]\n  h[3] <- 1-x[2]\n  return(h)\n}\nhin.jac <- function(x){\n  j <- matrix(NA,3,2)\n  j[1,] <- c(-1,1)\n  j[2,] <- c(1,0)\n  j[3,] <- c(0,-1)\n  return(j)\n}\n\nCI_95 <- function(post.bounds){\n  \n \n  p0 <- c(0.5,0.6)\n  ans <- auglag(par=p0,fn=fn,gr=gr,heq=heq,heq.jac = heq.jac,hin = hin,hin.jac = hin.jac)\n  return(ans$par)\n}\n\n\n\n\nmu <- c(0.5272844,0.6289225)\nmu1 <- mu[1]\nmu2 <- mu[2]\nSigma <- matrix(c(0.0003443427,0.0002887762,0.0002887762, 0.0003390882),2,2)\nsigma1 <- sqrt(2)\nsigma2 <- sqrt(4)\n\np <- Sigma[1,2]/(sigma1*sigma2)\n\nderivative_function <- function(par){\n  a <- par[1]\n  b <- par[2]\n  mu1 <- mu[1]\n  mu2 <- mu[2]\n  sigma1 <- sqrt(Sigma[1,1])\n  sigma2 <- sqrt(Sigma[2,2])\n  p <- Sigma[1,2]/(sigma1*sigma2)\n  muy_x <- mu2+p*sigma2*(a-mu1)/sigma1\n  sigmay_x <- sigma2^2*(1-p^2)\n  mux_y <- mu1+p*sigma1*(b-mu2)/sigma2\n  sigmax_y <- sigma1^2*(1-p^2)\n  \n  f_a <- dnorm(a,mean=mu1,sd=sigma1)-dnorm(a,mean=mu1,sd=sigma1)*pnorm(b,mean=muy_x,sd=sigmay_x)\n  f_b <- -dnorm(b,mean=mu2,sd=sigma2)*pnorm(a,mean=mux_y,sd=sigmay_x)\n  \n  tanget <- (-f_b/f_a-1)\n  return(tanget^2)\n}\n\nparstart <- c(2,3)\noptim(parstart,derivative_function)\nnleqslv(parstart,derivative_function)\nn <- 4800\ndata <- mvrnorm(n,mu,Sigma)\n\ncomputefunction <- function(a,b){\n \n  mu1 <- mu[1]\n  sigma1 <- sqrt(Sigma[1,1])\n  result <- pmvnorm(lower=c(a,-Inf),upper = c(Inf,b),mean=mu,sigma=Sigma)\n  return((result[1]-0.95))\n}\ncomputefunction_grad_1<- function(a,b){\n \n  mu1 <- mu[1]\n  mu2 <- mu[2]\n  sigma1 <- sqrt(Sigma[1,1])\n  sigma2 <- sqrt(Sigma[2,2])\n  p <- Sigma[1,2]/(sigma1*sigma2)\n  muy_x <- mu2+p*sigma2*(a-mu1)/sigma1\n  sigmay_x <- sqrt(sigma2^2*(1-p^2))\n  mux_y <- mu1+p*sigma1*(b-mu2)/sigma2\n  sigmax_y <- sqrt(sigma1^2*(1-p^2))\n  \n  f_a <- -dnorm(a,mean=mu1,sd=sigma1)*pnorm(b,mean=muy_x,sd=sigmay_x)\n  #f_b <- dnorm(b,mean=mu2,sd=sigma2)-dnorm(b,mean=mu2,sd=sigma2)*pnorm(a,mean=mux_y,sd=sigmay_x)\n  return(f_a)\n}\n\ncomputefunction_grad_2<- function(a,b){\n  \n  mu1 <- mu[1]\n  mu2 <- mu[2]\n  sigma1 <- sqrt(Sigma[1,1])\n  sigma2 <- sqrt(Sigma[2,2])\n  p <- Sigma[1,2]/(sigma1*sigma2)\n  muy_x <- mu2+p*sigma2*(a-mu1)/sigma1\n  sigmay_x <- sqrt(sigma2^2*(1-p^2))\n  mux_y <- mu1+p*sigma1*(b-mu2)/sigma2\n  sigmax_y <- sqrt(sigma1^2*(1-p^2))\n  \n  f_b <- dnorm(b,mean=mu2,sd=sigma2)-dnorm(b,mean=mu2,sd=sigma2)*pnorm(a,mean=mux_y,sd=sigmay_x)\n  return(f_b)\n}\na <- seq(min(data[,1]),max(data[,1]),0.001)\nvalue <- rep(0,length(a))\nb_result <- rep(0,length(a))\nfor(i in 1:length(a)){\n  try <- optim(0,computefunction,a=a[i],method = \"Brent\",lower = -10,upper = 10)\n  value[i] <- try$value\n  b_result[i] <- try$par-a[i]\n}\noptim(0,computefunction,a=0.58,method = \"Brent\",lower = -10,upper = 10)\nidx <- which(value<=1e-4)\nvalue <- value[idx]\na <- a[idx]\nb_result <- b_result[idx]\n\n\n# eval_f <- function(x){\n#   return(list(\"objective\"=x[2]-x[1],\n#               \"gradient\"=c(-1,1)))\n# }\n# eval_g_ineq <- function(x){\n#   constr <- c(x[1]-x[2])\n#   #grad <- c(1,-1)\n#   return(list(\"constrains\"=constr))\n# }\n# eval_g_eq <- function(x){\n#   constr <- computefunction(x[1],x[2])\n#  # grad <- c(computefunction_grad_1(x[1],x[2]),\n#           #  computefunction_grad_2(x[1],x[2]))\n#   #return(list(\"constrains\"=constr,\n#               #\"jacobian\"=grad))\n#   return(list(\"constrains\"=constr))\n# }\n# x0 <- c(0.4,0.6)\n# local_opts <-  list( \"algorithm\" = \"NLOPT_LD_MMA\",\n#                       \"xtol_rel\" = 1.0e-7 )\n# opts <- list( \"algorithm\" = \"NLOPT_LD_AUGLAG\",\n#               \"xtol_rel\" = 1.0e-7,\n#               \"maxeval\" = 1000,\n#               \"local_opts\" = local_opts )\n# res <- nloptr( x0=x0,\n#                eval_f=eval_f,\n#                 eval_g_eq=eval_g_eq,\n#                opts=opts)\n\n\n\n#  objfun <- function(x){\n#    return(x[2]-x[1])\n#  }\n#  confun <- function(x){\n#    f <- NULL\n#    f <- rbind(f,computefunction(x[1],x[2]))\n#    return(list(ceq=f,c=NULL))\n#  }\n#  x0 <- c(0.5,0.7)\n#  NlcOptim(x0,objfun=objfun,confun=confun)\n# \n# fn1 <-  function(x){\n#      return(x[2]-x[1])\n# }\n# eqn1 <- function(x){\n#   return(computefunction(x[1],x[2]))\n# }\n# eqB <- 0\n# x0 <- c(0.4,0.7)\n# result <- solnp(x0,fun=fn1,eqfun=eqn1,eqB=eqB)\n\n fn <- function(x){return(x[2]-x[1])}\n gr <- function(x){\n   g <- rep(NA,2)\n    g[1] <- -1\n   g[2] <- 1\n   return(g)\n }\n heq <- function(x){\n   h <- (computefunction(x[1],x[2]))\n   return(h)\n }\n heq.jac <- function(x){\n   j <- matrix(NA,1,length(x))\n   j[1,1] <- computefunction_grad_1(x[1],x[2])\n   j[1,2] <- computefunction_grad_2(x[1],x[2])\n }\n\n p0 <- c(0.5,0.7)\n ans <- auglag(par=p0,fn=fn,gr=gr,heq=heq)\n \n \n x1 = runif (10)\n x2 = runif (10)\n x = cbind (x1, x2)\n m = mecdf (x)\n\nlibrary(data.table)\nlibrary(mltools)\n \n \n x.seq <- seq(min(x),max(x),0.001)\n y.seq <- seq(min(y),max(y),0.001)\n n <- nrow(post.bounds)\n pdf <- rep(0,nrow((x.y)))\n x.y <- expand.grid(x.seq,y.seq)\n for( i in 1:nrow(x.y)){\n   if(i%%1000==0){\n     print(i)\n   }\n   idx <- which(post.bounds[,1]>=x.y[i,1]&post.bounds[,2]<=x.y[i,2])\n   pdf[i] <- length(idx)/n\n }\n \n \n result <- data.frame(x.y,pdf=pdf)\n \n \n CI_empircal_2 <- function(post.bounds){\n   x <- post.bounds[,1]\n   y <- post.bounds[,2]\n   max_x <- quantile(x,probs = 0.05)\n   x.seq <- seq(min(x),max_x,0.001)\n   y.seq <- seq(min(y),max(y),0.001)\n   n <- nrow(post.bounds)\n   x.y <- expand.grid(x.seq,y.seq)\n   pdf <- rep(0,nrow((x.y)))\n   colnames(x.y) <- c(\"x\",\"y\")\n   for( i in 1:nrow(x.y)){\n     idx <- which(post.bounds[,1]>=x.y[i,1]&post.bounds[,2]<=x.y[i,2])\n     pdf[i] <- length(idx)/n\n   }\n   result <- data.frame(x.y,pdf=pdf)\n   \n   idx <- which(abs(result$pdf-0.95)<1e-03)\n   differ <- result$y[idx]-result$x[idx]\n   jdx <- which.min(differ)\n   x.y.95 <- cbind(result$x[idx],result$y[idx])\n   if(length(jdx)>1){\n     jdx <- jdx[1]\n   }\n   final <- x.y.95[jdx,]\n   return(final)\n   \n }\n \n \n CI95_empircal <- function(post.bounds){\n   x <- post.bounds[,1]\n   y <- post.bounds[,2]\n   max_x <- quantile(x,probs = 0.05)\n   x.seq <- seq(min(x),max_x,0.001)\n   y.seq <- seq(min(y),max(y),0.001)\n   n <- nrow(post.bounds)\n   x.y <- expand.grid(x.seq,y.seq)\n   pdf <- rep(0,nrow((x.y)))\n   colnames(x.y) <- c(\"x\",\"y\")\n   for( i in 1:nrow(x.y)){\n     idx <- which(post.bounds[,1]>=x.y[i,1]&post.bounds[,2]<=x.y[i,2])\n     pdf[i] <- length(idx)/n\n   }\n   result <- data.frame(x.y,pdf=pdf)\n   \n   idx <- which(abs(result$pdf-0.95)<1e-03)\n   differ <- result$y[idx]-result$x[idx]\n   jdx <- which.min(differ)\n   x.y.95 <- cbind(result$x[idx],result$y[idx])\n   if(length(jdx)>1){\n     jdx <- jdx[1]\n   }\n   final <- x.y.95[jdx,]\n   return(final)\n   }\n x <- post.bounds[,1]\n y <- post.bounds[,2]\ndt <- data.table(x=x,y=y)\ncolnames(dt) <- c(\"x\",\"y\")\nresult <- empirical_cdf(dt,ubounds=list(x=seq(min(x),max(x),0.001),y=seq(min(y),max(y),0.001)))\n\n\n",
    "created" : 1484155322163.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2182272060",
    "id" : "1D3C9190",
    "lastKnownWriteTime" : 1484286553,
    "last_content_update" : 1484286553306,
    "path" : "~/Documents/study/advanced_stat_theory/optimization_project/scrath.R",
    "project_path" : "scrath.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}